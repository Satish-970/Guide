<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DSA â€” Complete Conceptual Guide (Book)</title>
  <link rel="stylesheet" href="../assets/styles.css">

  <!-- LOCAL OVERRIDES: do NOT change central css -->
  <style>
    /* Page-scoped layout fixes so header sits above content beside the fixed sidebar */
    body.dsa-page .header { margin-left: 280px !important; width: calc(100% - 280px) !important; }
    body.dsa-page .content { margin-left: 280px !important; padding-top: 18px !important; }
    body.dsa-page .layout { width: 100% !important; display: block !important; }
    body.dsa-page .container { margin: 0 !important; width: 100% !important; max-width: none !important; background: none !important; box-shadow: none !important; border: none !important; }
    /* Make panels a bit wider for long examples */
    body.dsa-page .panel { max-width: none; }
    /* Small improvements for code blocks inside this page */
    .dsa-code-fn { display:block; margin:0.4rem 0; font-weight:600; color:#00ff88; }
    /* Floating quick index (optional) */
    .quick-outline {
      position: fixed;
      right: 18px;
      top: 110px;
      width: 240px;
      max-height: 70vh;
      overflow:auto;
      background: rgba(10,10,10,0.8);
      border: 1px solid #1a1a1a;
      padding: 12px;
      border-radius: 10px;
      z-index: 1200;
      color: #a0a0a0;
    }
    .quick-outline h4 { color:#00ff88; margin-bottom:8px; }
    .quick-outline a { display:block; padding:6px 0; color:#a0a0a0; text-decoration:none; }
    .quick-outline a:hover { color:#00ff88; }
    /* Ensure chatbot is on top */
    #chatbotWindow { z-index:1600; }
  </style>
</head>
<body class="guide dsa-page">

  <!-- Sidebar toggle + Sidebar (keeps central markup) -->
  <button class="sidebar-toggle">â˜° Menu</button>
  <aside class="sidebar" aria-label="Table of contents">
    <div class="toc-title">DSA Guide</div>
    <div class="search-container">
      <input id="searchInput" placeholder="Search topics..." />
    </div>
    <ul class="toc">
      <li><a href="#intro">Introduction</a></li>
      <li><a href="#complexity">Complexity Guide</a></li>
      <li><a href="#arrays">Arrays</a></li>
      <li><a href="#linkedlist">Linked Lists</a></li>
      <li><a href="#stack">Stack</a></li>
      <li><a href="#queue">Queue</a></li>
      <li><a href="#hashing">Hashing</a></li>
      <li><a href="#strings">Strings</a></li>
      <li><a href="#sorting">Sorting</a></li>
      <li><a href="#searching">Searching</a></li>
      <li><a href="#trees">Trees</a></li>
      <li><a href="#bst">Binary Search Tree</a></li>
      <li><a href="#heap">Heap / Priority Queue</a></li>
      <li><a href="#graphs">Graphs</a></li>
      <li><a href="#dp">Dynamic Programming</a></li>
      <li><a href="#backtracking">Backtracking</a></li>
      <li><a href="#greedy">Greedy</a></li>
      <li><a href="#two-pointers">Two Pointers</a></li>
      <li><a href="#sliding-window">Sliding Window</a></li>
      <li><a href="#bit-manipulation">Bit Manipulation</a></li>
      <li><a href="#union-find">Union-Find</a></li>
      <li><a href="#tries">Tries</a></li>
      <li><a href="#segment-fenwick">Segment/Fenwick Trees</a></li>
      <li><a href="#patterns">Problem Patterns</a></li>
      <li><a href="#templates">Coding Templates</a></li>
      <li><a href="#practice">Practice Problems</a></li>
    </ul>
  </aside>

  <!-- main layout -->
  <div class="layout">

    <!-- Header -->
    <header class="header">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>DSA â€” Complete Conceptual Guide (Book)</h1>
          <div class="subtitle muted">Intuition â€¢ Patterns â€¢ Templates â€¢ Problems â€” Interview ready</div>
        </div>
      </div>

      <div class="top-actions">
        <button class="btn" onclick="toggleFocusMode()">ðŸŽ¯ Focus Mode</button>
        <button class="btn ghost" onclick="toggleChatbot()">ðŸ’¬ Chatbot</button>
      </div>
    </header>

    <!-- floating quick outline -->
    <nav class="quick-outline" aria-hidden="false">
      <h4>Quick Outline</h4>
      <a href="#arrays">Arrays</a>
      <a href="#linkedlist">LinkedList</a>
      <a href="#trees">Trees</a>
      <a href="#graphs">Graphs</a>
      <a href="#dp">Dynamic Programming</a>
      <a href="#patterns">Patterns</a>
      <a href="#templates">Templates</a>
    </nav>

    <!-- Content -->
    <main class="content panel" role="main">

      <!-- INTRO -->
      <section id="intro" class="panel">
        <h2>How to use this guide</h2>
        <p>This is a deep, interview-ready DSA handbook. Each topic: quick definition, intuition, naive example, optimized approach, complexity, pitfalls, interview notes and problems.</p>
        <ul class="bullets">
          <li>Read intuition first â€” code second.</li>
          <li>Learn templates â€” they map directly to interview patterns.</li>
          <li>Practice the problems in <strong>Practice Problems</strong> section.</li>
        </ul>
      </section>

      <!-- COMPLEXITY -->
      <section id="complexity" class="panel">
        <h2>Complexity Guide (Big-O quick reference)</h2>
        <p>Common operation costs â€” memorize these.</p>
        <ul class="bullets">
          <li>Array access: O(1)</li>
          <li>Array insert/delete (mid): O(n)</li>
          <li>Linked list insert/delete at head: O(1)</li>
          <li>HashMap lookup/insert (avg): O(1), worst O(n)</li>
          <li>BST balanced operations: O(log n), skewed O(n)</li>
          <li>Heap push/pop: O(log n)</li>
          <li>DFS/BFS: O(V + E)</li>
          <li>Sorting (comparison): O(n log n) average (merge/quick), O(n^2) naive</li>
        </ul>
      </section>

      <!-- ARRAYS -->
      <section id="arrays" class="panel">
        <h2>Arrays â€” concept & usage</h2>
        <p><strong>Intuition:</strong> contiguous memory, fast indexing, used when size mostly known or random access is needed.</p>

        <h3>Naive â€” Find Maximum</h3>
        <div class="code" id="arr-max">
          <button class="copy" onclick="copyCode('arr-max')">Copy</button>
<pre>
int max(int[] arr) {
    if (arr == null || arr.length==0) return Integer.MIN_VALUE;
    int m = arr[0];
    for (int i=1; i<arr.length; i++) if (arr[i] > m) m = arr[i];
    return m;
}
</pre>
        </div>

        <h3>Optimize? â€” When to optimize</h3>
        <p>If scanning repeatedly, build prefix/suffix arrays, segment tree, or maintain running aggregates.</p>

        <h3>In-place rotate (common pattern)</h3>
        <div class="code" id="arr-rotate">
          <button class="copy" onclick="copyCode('arr-rotate')">Copy</button>
<pre>
void rotateRight(int[] a, int k) {
    k = k % a.length;
    reverse(a, 0, a.length-1);
    reverse(a, 0, k-1);
    reverse(a, k, a.length-1);
}
void reverse(int[] a, int l, int r) {
    while (l < r) { int t = a[l]; a[l++] = a[r]; a[r--] = t; }
}
</pre>
        </div>

        <h3>Pitfalls</h3>
        <ul class="bullets">
          <li>Off-by-one on indices</li>
          <li>Null and empty checks</li>
          <li>Beware integer overflow in loops? use l + (r-l)/2 in binary search</li>
        </ul>
      </section>

      <!-- LINKED LIST -->
      <section id="linkedlist" class="panel">
        <h2>Linked Lists</h2>
        <p><strong>Intuition:</strong> nodes with pointers â€” flexible size, cheap insert/delete at ends.</p>

        <h3>Naive â€” Reverse (iterative)</h3>
        <div class="code" id="ll-reverse">
          <button class="copy" onclick="copyCode('ll-reverse')">Copy</button>
<pre>
class Node { int v; Node next; Node(int x){v=x;} }
Node reverse(Node head) {
    Node prev=null, cur=head;
    while(cur!=null){
        Node tmp=cur.next; cur.next=prev; prev=cur; cur=tmp;
    }
    return prev;
}
</pre>
        </div>

        <h3>Find middle (two-pointer)</h3>
        <div class="code" id="ll-mid">
          <button class="copy" onclick="copyCode('ll-mid')">Copy</button>
<pre>
Node middle(Node head) {
    Node slow=head, fast=head;
    while(fast!=null && fast.next!=null){ slow=slow.next; fast=fast.next.next; }
    return slow;
}
</pre>
        </div>

        <h3>Use cases</h3>
        <ul class="bullets">
          <li>Implement stacks/queues, adjacency lists</li>
        </ul>
      </section>

      <!-- STACK -->
      <section id="stack" class="panel">
        <h2>Stack (LIFO)</h2>
        <p>Use for recursion emulation, backtracking, expression parsing.</p>

        <h3>Naive â€” Balanced parentheses</h3>
        <div class="code" id="stack-paren">
          <button class="copy" onclick="copyCode('stack-paren')">Copy</button>
<pre>
boolean isBalanced(String s){
    java.util.Stack&lt;Character&gt; st = new java.util.Stack&lt;&gt;();
    for(char c : s.toCharArray()){
        if(c=='(') st.push(c);
        else if(c==')'){ if(st.isEmpty()) return false; st.pop(); }
    }
    return st.isEmpty();
}
</pre>
        </div>

        <h3>Template: iterative DFS</h3>
        <div class="code" id="stack-dfs">
          <button class="copy" onclick="copyCode('stack-dfs')">Copy</button>
<pre>
void dfsIter(int src, List&lt;Integer&gt;[] adj) {
    boolean[] vis = new boolean[adj.length];
    java.util.Stack&lt;Integer&gt; st = new java.util.Stack&lt;&gt;();
    st.push(src);
    while(!st.isEmpty()){
        int u = st.pop();
        if(vis[u]) continue;
        vis[u]=true;
        // process u
        for(int v : adj[u]) if(!vis[v]) st.push(v);
    }
}
</pre>
        </div>
      </section>

      <!-- QUEUE -->
      <section id="queue" class="panel">
        <h2>Queue (FIFO)</h2>
        <p>Great for BFS, producer-consumer. Use circular buffer or LinkedList.</p>

        <h3>BFS template</h3>
        <div class="code" id="bfs-template">
          <button class="copy" onclick="copyCode('bfs-template')">Copy</button>
<pre>
void bfs(int s, List&lt;Integer&gt;[] adj) {
    boolean[] vis = new boolean[adj.length];
    java.util.Queue&lt;Integer&gt; q = new java.util.LinkedList&lt;&gt;();
    q.add(s); vis[s]=true;
    while(!q.isEmpty()){
        int u=q.remove();
        // process u
        for(int v: adj[u]) if(!vis[v]) { vis[v]=true; q.add(v); }
    }
}
</pre>
        </div>
      </section>

      <!-- HASHING -->
      <section id="hashing" class="panel">
        <h2>Hashing / HashMap</h2>
        <p>Average O(1) mapping. Good for frequency, dedup, caching.</p>

        <h3>Counting frequencies</h3>
        <div class="code" id="hash-freq">
          <button class="copy" onclick="copyCode('hash-freq')">Copy</button>
<pre>
Map&lt;Integer,Integer&gt; freq(int[] a){
    Map&lt;Integer,Integer&gt; m = new java.util.HashMap&lt;&gt;();
    for(int x: a) m.put(x, m.getOrDefault(x,0)+1);
    return m;
}
</pre>
        </div>

        <h3>Collision & worst-case</h3>
        <p>Use good hash function; Java's built-in handles most primitives/strings well. For adversarial data, consider tree bins (Java 8+) or alternative maps.</p>
      </section>

      <!-- STRINGS -->
      <section id="strings" class="panel">
        <h2>Strings â€” patterns & common tasks</h2>
        <p>String problems often reduce to sliding-window, hashing (rolling hash), KMP, or two pointers.</p>

        <h3>Naive â€” substring search</h3>
        <div class="code" id="str-index">
          <button class="copy" onclick="copyCode('str-index')">Copy</button>
<pre>
int indexOf(String s, String p) {
    for(int i=0;i+ p.length()<=s.length(); i++){
        if(s.substring(i, i+p.length()).equals(p)) return i;
    }
    return -1;
}
</pre>
        </div>

        <h3>KMP outline (use for guaranteed O(n))</h3>
        <p>Precompute lps table, then single pass.</p>
      </section>

      <!-- SORTING -->
      <section id="sorting" class="panel">
        <h2>Sorting â€” naive â†’ efficient</h2>
        <p>Remember: comparison sorts cannot beat O(n log n) average using comparisons.</p>

        <h3>Bubble Sort (naive)</h3>
        <div class="code" id="bubble">
          <button class="copy" onclick="copyCode('bubble')">Copy</button>
<pre>
void bubbleSort(int[] a){
  int n=a.length;
  for(int i=0;i<n-1;i++){
    for(int j=0;j<n-1-i;j++){
      if(a[j]>a[j+1]){ int t=a[j]; a[j]=a[j+1]; a[j+1]=t; }
    }
  }
}
</pre>
        </div>

        <h3>Merge Sort (stable, O(n log n))</h3>
        <div class="code" id="merge">
          <button class="copy" onclick="copyCode('merge')">Copy</button>
<pre>
void mergeSort(int[] a, int l, int r){
  if(l>=r) return;
  int m=(l+r)/2;
  mergeSort(a, l, m);
  mergeSort(a, m+1, r);
  merge(a, l, m, r);
}
// merge uses temp array
</pre>
        </div>

        <h3>QuickSort (average O(n log n), worst O(n^2))</h3>
        <p>Randomized pivot avoids worst-case on sorted inputs.</p>
      </section>

      <!-- SEARCHING -->
      <section id="searching" class="panel">
        <h2>Searching</h2>
        <h3>Binary search template (iterative)</h3>
        <div class="code" id="binary">
          <button class="copy" onclick="copyCode('binary')">Copy</button>
<pre>
int binarySearch(int[] a, int target){
  int l=0, r=a.length-1;
  while(l<=r){
    int m = l + (r-l)/2;
    if(a[m]==target) return m;
    if(a[m] < target) l = m+1; else r = m-1;
  }
  return -1;
}
</pre>
        </div>
      </section>

      <!-- TREES -->
      <section id="trees" class="panel">
        <h2>Trees</h2>
        <p>Hierarchical structures. Use recursion for traversals.</p>

        <h3>DFS traversals â€” recursive templates</h3>
        <div class="code" id="tree-traverse">
          <button class="copy" onclick="copyCode('tree-traverse')">Copy</button>
<pre>
void inorder(Node root){
  if(root==null) return;
  inorder(root.left);
  visit(root);
  inorder(root.right);
}
</pre>
        </div>

        <h3>Tree problems: lowest common ancestor (LCA)</h3>
        <p>Use parent+depth lifting (binary lifting) for repeated LCA queries; use recursion for single queries.</p>
      </section>

      <!-- BST -->
      <section id="bst" class="panel">
        <h2>Binary Search Tree</h2>
        <p>Properties: left &lt; node &lt; right. Balanced BSTs (AVL, Red-Black) guarantee O(log n).</p>

        <h3>Search/insert (naive)</h3>
        <div class="code" id="bst-ins">
          <button class="copy" onclick="copyCode('bst-ins')">Copy</button>
<pre>
Node insert(Node root, int key){
  if(root==null) return new Node(key);
  if(key < root.val) root.left = insert(root.left, key);
  else root.right = insert(root.right, key);
  return root;
}
</pre>
        </div>
      </section>

      <!-- HEAP -->
      <section id="heap" class="panel">
        <h2>Heap / Priority Queue</h2>
        <p>Binary heap supports push/pop in O(log n). Java: PriorityQueue.</p>

        <h3>Use-case: kth smallest</h3>
        <div class="code" id="kth-small">
          <button class="copy" onclick="copyCode('kth-small')">Copy</button>
<pre>
int kthSmallest(int[] a, int k){
  PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();
  for(int x: a) pq.add(x);
  for(int i=1;i<k;i++) pq.poll();
  return pq.poll();
}
</pre>
        </div>
      </section>

      <!-- GRAPHS -->
      <section id="graphs" class="panel">
        <h2>Graphs</h2>
        <p>Representations: adjacency list (preferred), adjacency matrix (dense). Problems: connectivity, shortest path, cycles, topological order.</p>

        <h3>BFS & shortest unweighted</h3>
        <div class="code" id="graph-bfs2">
          <button class="copy" onclick="copyCode('graph-bfs2')">Copy</button>
<pre>
int[] distances(List&lt;Integer&gt;[] adj, int s){
  int n=adj.length; int[] dist = new int[n]; Arrays.fill(dist, -1);
  Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.add(s); dist[s]=0;
  while(!q.isEmpty()){
    int u=q.remove();
    for(int v: adj[u]) if(dist[v]==-1){ dist[v]=dist[u]+1; q.add(v); }
  }
  return dist;
}
</pre>
        </div>

        <h3>Dijkstra (weighted, non-negative)</h3>
        <div class="code" id="dijkstra">
          <button class="copy" onclick="copyCode('dijkstra')">Copy</button>
<pre>
void dijkstra(int src, List&lt;Pair&gt;[] adj) {
  int n=adj.length; long[] dist = new long[n]; Arrays.fill(dist, Long.MAX_VALUE);
  PriorityQueue&lt;Pair&gt; pq = new PriorityQueue&lt;&gt;((a,b)->Long.compare(a.w,b.w));
  dist[src]=0; pq.add(new Pair(src,0));
  while(!pq.isEmpty()){
    Pair p=pq.poll(); int u=p.v;
    if(p.w>dist[u]) continue;
    for(Pair e: adj[u]){
      if(dist[e.v] > dist[u] + e.w){
        dist[e.v] = dist[u] + e.w;
        pq.add(new Pair(e.v, dist[e.v]));
      }
    }
  }
}
</pre>
        </div>

        <h3>Topological Sort (DAG)</h3>
        <div class="code" id="topo">
          <button class="copy" onclick="copyCode('topo')">Copy</button>
<pre>
List&lt;Integer&gt; topo(int n, List&lt;Integer&gt;[] adj){
  int[] indeg = new int[n]; for(int u=0;u<n;u++) for(int v:adj[u]) indeg[v]++;
  Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for(int i=0;i<n;i++) if(indeg[i]==0) q.add(i);
  List&lt;Integer&gt; order = new ArrayList&lt;&gt;();
  while(!q.isEmpty()){ int u=q.remove(); order.add(u);
    for(int v: adj[u]) if(--indeg[v]==0) q.add(v);
  }
  return order;
}
</pre>
        </div>
      </section>

      <!-- DYNAMIC PROGRAMMING -->
      <section id="dp" class="panel">
        <h2>Dynamic Programming</h2>
        <p>Two approaches: memoization (top-down) and tabulation (bottom-up). Identify overlapping subproblems and optimal substructure.</p>

        <h3>Fibonacci â€” naive vs memo vs tabulation</h3>
        <div class="code" id="fib-naive">
          <button class="copy" onclick="copyCode('fib-naive')">Copy</button>
<pre>
int fib(int n){ if(n<=1) return n; return fib(n-1) + fib(n-2); } // exponential
</pre>
        </div>

        <div class="code" id="fib-memo">
          <button class="copy" onclick="copyCode('fib-memo')">Copy</button>
<pre>
int fibMemo(int n, int[] memo){
  if(n<=1) return n;
  if(memo[n]!=-1) return memo[n];
  return memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo);
}
</pre>
        </div>

        <h3>Knapsack (0/1) â€” DP table outline</h3>
        <div class="code" id="knap">
          <button class="copy" onclick="copyCode('knap')">Copy</button>
<pre>
// dp[i][w] = max value using first i items with capacity w
for(i=1..n) for(w=0..W) dp[i][w] = max(dp[i-1][w], val[i] + dp[i-1][w-weight[i]]);
</pre>
        </div>
      </section>

      <!-- BACKTRACKING -->
      <section id="backtracking" class="panel">
        <h2>Backtracking</h2>
        <p>Explore choices, backtrack on failure. Use for permutations, combinations, N-Queens, Sudoku.</p>

        <h3>N-Queens outline (place row-by-row)</h3>
        <div class="code" id="nqueens">
          <button class="copy" onclick="copyCode('nqueens')">Copy</button>
<pre>
void solve(int r, int n, boolean[] col, boolean[] diag1, boolean[] diag2){
  if(r==n){ /* found */ return; }
  for(int c=0;c<n;c++){
    if(col[c] || diag1[r+c] || diag2[r-c+n-1]) continue;
    col[c]=diag1[r+c]=diag2[r-c+n-1]=true;
    solve(r+1,n,col,diag1,diag2);
    col[c]=diag1[r+c]=diag2[r-c+n-1]=false;
  }
}
</pre>
        </div>
      </section>

      <!-- GREEDY -->
      <section id="greedy" class="panel">
        <h2>Greedy</h2>
        <p>Take local optimal choice; proof often by exchange argument. Examples: activity selection, Huffman coding, fractional knapsack.</p>
      </section>

      <!-- TWO-POINTERS / SLIDING WINDOW -->
      <section id="two-pointers" class="panel">
        <h2>Two Pointers</h2>
        <p>Use two indices to scan from ends or to maintain window boundaries. Reduce O(n^2) â†’ O(n).</p>

        <h3>Two-sum (sorted)</h3>
        <div class="code" id="two-sum">
          <button class="copy" onclick="copyCode('two-sum')">Copy</button>
<pre>
int[] twoSumSorted(int[] a, int t){
  int l=0, r=a.length-1;
  while(l<r){
    int s=a[l]+a[r];
    if(s==t) return new int[]{l,r};
    if(s<t) l++; else r--;
  }
  return new int[]{-1,-1};
}
</pre>
        </div>
      </section>

      <section id="sliding-window" class="panel">
        <h2>Sliding Window</h2>
        <p>Use variable window [l..r] to maintain invariant (sum, counts). Classic: longest substring w/o repeating chars, subarray sum equals K (positives).</p>

        <h3>Longest substring without repeating</h3>
        <div class="code" id="longest-unique">
          <button class="copy" onclick="copyCode('longest-unique')">Copy</button>
<pre>
int longestUnique(String s){
  int[] last = new int[256]; Arrays.fill(last, -1);
  int l=0, best=0;
  for(int r=0;r<s.length();r++){
    l = Math.max(l, last[s.charAt(r)]+1);
    best = Math.max(best, r-l+1);
    last[s.charAt(r)] = r;
  }
  return best;
}
</pre>
        </div>
      </section>

      <!-- BIT MANIPULATION -->
      <section id="bit-manipulation" class="panel">
        <h2>Bit Manipulation</h2>
        <p>Useful for parity, subsets, masks. Know: &, |, ^, ~, <<, >>, bit tricks (x & -x gives lowest set bit).</p>

        <h3>Count bits (Brian Kernighan)</h3>
        <div class="code" id="popcount">
          <button class="copy" onclick="copyCode('popcount')">Copy</button>
<pre>
int popcount(int x){
  int cnt=0;
  while(x!=0){ x &= (x-1); cnt++; }
  return cnt;
}
</pre>
        </div>
      </section>

      <!-- UNION FIND -->
      <section id="union-find" class="panel">
        <h2>Union-Find (Disjoint Set)</h2>
        <p>Maintain connected components with union by rank & path compression: near O(1) amortized.</p>

        <div class="code" id="uf">
          <button class="copy" onclick="copyCode('uf')">Copy</button>
<pre>
int[] parent, rank;
int find(int x){ return parent[x]==x ? x : (parent[x]=find(parent[x])); }
void union(int a, int b){
  a=find(a); b=find(b);
  if(a==b) return;
  if(rank[a]<rank[b]) parent[a]=b; else if(rank[b]<rank[a]) parent[b]=a;
  else { parent[b]=a; rank[a]++; }
}
</pre>
        </div>
      </section>

      <!-- TRIES -->
      <section id="tries" class="panel">
        <h2>Tries (Prefix Trees)</h2>
        <p>Fast prefix search and word validation. Memory-heavy but fast lookups for strings.</p>

        <div class="code" id="trie">
          <button class="copy" onclick="copyCode('trie')">Copy</button>
<pre>
class TrieNode { TrieNode[] next = new TrieNode[26]; boolean end=false; }
void insert(TrieNode root, String s){
  TrieNode cur=root;
  for(char c: s.toCharArray()){
    int i = c-'a'; if(cur.next[i]==null) cur.next[i]=new TrieNode();
    cur = cur.next[i];
  }
  cur.end=true;
}
</pre>
        </div>
      </section>

      <!-- SEGMENT & FENWICK -->
      <section id="segment-fenwick" class="panel">
        <h2>Segment Tree & Fenwick (Binary Indexed Tree)</h2>
        <p>Range queries & updates: Fenwick for prefix sums (simple), Segment tree for range queries combining arbitrary assoc ops.</p>

        <div class="code" id="fenwick">
          <button class="copy" onclick="copyCode('fenwick')">Copy</button>
<pre>
class Fenwick {
  int n; long[] bit;
  Fenwick(int n){ this.n=n; bit=new long[n+1]; }
  void add(int i, long val){ for(; i<=n; i += i&-i) bit[i]+=val; }
  long sum(int i){ long s=0; for(; i>0; i -= i&-i) s+=bit[i]; return s; }
}
</pre>
        </div>
      </section>

      <!-- PATTERNS -->
      <section id="patterns" class="panel">
        <h2>Problem Patterns</h2>
        <ul class="bullets">
          <li><strong>Sliding window</strong> â€” continuous subarray/string problems</li>
          <li><strong>Two pointers</strong> â€” sorted pair problems, remove duplicates</li>
          <li><strong>Prefix sum</strong> â€” subarray sums, range queries</li>
          <li><strong>Hashing</strong> â€” counting, dedupe, two-sum (unsorted)</li>
          <li><strong>DFS/BFS</strong> â€” traverse graphs/trees</li>
          <li><strong>DP patterns</strong> â€” knapsack, LIS, partition</li>
          <li><strong>Greedy</strong> â€” scheduling, interval selection</li>
        </ul>
      </section>

      <!-- TEMPLATES -->
      <section id="templates" class="panel">
        <h2>Coding Templates (copy & adapt)</h2>

        <h3>Binary Search (lower_bound style)</h3>
        <div class="code" id="templ-binary">
          <button class="copy" onclick="copyCode('templ-binary')">Copy</button>
<pre>
int lowerBound(int[] a, int target){
  int l=0, r=a.length;
  while(l<r){
    int m = l + (r-l)/2;
    if(a[m] < target) l = m+1; else r = m;
  }
  return l;
}
</pre>
        </div>

        <h3>DFS recursive template (graphs)</h3>
        <div class="code" id="templ-dfs">
          <button class="copy" onclick="copyCode('templ-dfs')">Copy</button>
<pre>
void dfs(int u, List&lt;Integer&gt;[] adj, boolean[] vis){
  vis[u]=true;
  // process u
  for(int v: adj[u]) if(!vis[v]) dfs(v, adj, vis);
}
</pre>
        </div>
      </section>

      <!-- PRACTICE PROBLEMS -->
      <section id="practice" class="panel">
        <h2>Practice Problems (Easy â†’ Hard)</h2>
        <ol>
          <li>Easy: Two Sum (array), Reverse Linked List, Merge Two Sorted Lists, Valid Parentheses</li>
          <li>Medium: Longest Substring Without Repeating Characters, Group Anagrams, Lowest Common Ancestor</li>
          <li>Hard: Word Ladder II, N-Queens II, Median of Two Sorted Arrays, Graph longest path (DAG)</li>
        </ol>

        <h3>Interview strategy</h3>
        <ul class="bullets">
          <li>Explain thought process clearly; pick correct data structure and complexity target.</li>
          <li>Start with naive solution, then optimize.</li>
          <li>Write clean code, mention edge cases & complexity.</li>
        </ul>
      </section>

      <!-- modal for code preview -->
      <div id="modal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
        <div class="modal-inner">
          <button class="modal-close" onclick="closeModal()">âœ•</button>
          <pre id="modal-code" style="white-space: pre-wrap;"></pre>
        </div>
      </div>

      <!-- Chatbot (simple UI) -->
      <aside id="chatbotWindow" class="chatbot" style="position:fixed; right:20px; bottom:20px; width:360px; max-height:520px; display:none;">
        <div style="background:#111; border:1px solid #00ff88; border-radius:10px; overflow:hidden;">
          <div style="padding:10px; color:#00ff88; font-weight:700;">DSA Chatbot â€” quick help</div>
          <div id="chatbotMessages" style="height:360px; overflow:auto; padding:10px; background:#0a0a0a;"></div>
          <div style="display:flex; gap:8px; padding:10px;">
            <input id="chatInput" onkeydown="handleChatKeyPress(event)" placeholder="Ask about arrays, trees..." style="flex:1; padding:8px; background:#111; border:1px solid #1a1a1a; color:#e0e0e0;" />
            <button class="btn" onclick="sendMessage()" style="padding:8px 10px;">Send</button>
          </div>
        </div>
      </aside>

      <!-- Footer -->
      <footer class="footer">
        
        <div class="built-by">Â© 2025 âš¡ Built with passion by Satish â€¢ For learners, by a learner</div>
      </footer>

    </main>
  </div>

  <!-- central script (unchanged) -->
  <script src="../assets/scripts.js"></script>

  <!-- Page-local JS enhancements -->
  <script>
    // Sidebar search (page-local) â€” preserves central JS
    (function () {
      const input = document.getElementById('searchInput');
      const tocItems = Array.from(document.querySelectorAll('.toc li'));
      if (!input) return;
      input.addEventListener('input', function () {
        const q = this.value.trim().toLowerCase();
        tocItems.forEach(li => {
          const a = li.querySelector('a');
          const txt = a.textContent.toLowerCase();
          li.style.display = txt.includes(q) ? '' : 'none';
        });
      });
    })();

    // Copy helper fallback if central copyCode not found
    if (typeof copyCode !== 'function') {
      window.copyCode = function (id) {
        const el = document.getElementById(id);
        if (!el) return alert('Code block not found');
        const text = el.innerText.replace(/Copy.*$/g,'').trim();
        navigator.clipboard.writeText(text).then(()=> alert('Copied')).catch(()=> alert('Copy failed'));
      };
    }

    // Double-click to open modal on code blocks
    document.querySelectorAll('.code').forEach(block => {
      block.addEventListener('dblclick', () => {
        const id = block.id;
        if (id && typeof openModalWithCode === 'function') openModalWithCode(id);
      });
    });

    // Ensure chatbot initial hidden state
    document.getElementById('chatbotWindow').classList.remove('active');
    (function watchChatbotToggle(){
      const el = document.getElementById('chatbotWindow');
      const obs = new MutationObserver(() => { el.style.display = el.classList.contains('active') ? 'block' : 'none'; });
      obs.observe(el, { attributes: true, attributeFilter: ['class']});
    })();

    // Minor smooth scroll on load if hash present (central JS may already handle)
    if (window.location.hash) {
      setTimeout(() => {
        const t = document.querySelector(window.location.hash);
        if (t) t.scrollIntoView({behavior:'smooth', block:'start'});
      }, 250);
    }
  </script>
</body>
</html>

